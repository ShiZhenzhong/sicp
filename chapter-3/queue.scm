;; implement pair with procedures
(define (i-cons x y)
  (define (dispatch m)
    (cond ((eq? 'i-car m) x)
          ((eq? 'i-cdr m) y)
          ((eq? 'i-set-car! m) (lambda (new-car) (set! x new-car)))
          ((eq? 'i-set-cdr! m) (lambda (new-cdr) (set! y new-cdr)))
          (else (error "BAD FUNCTION"))))
  dispatch)
(define (i-car pair) (pair 'i-car))
(define (i-cdr pair) (pair 'i-cdr))
(define (i-set-car! pair new-car) ((pair 'i-set-car!) new-car))
(define (i-set-cdr! pair new-cdr) ((pair 'i-set-cdr!) new-cdr))

; queue
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))

(define make-queue (lambda () (cons '() '())))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (if (empty-queue? queue)
      (begin (set-front-ptr! queue new-pair)
             (set-rear-ptr! queue new-pair)
             (print-queue queue))
      (begin (set-cdr! (rear-ptr queue) new-pair)
             (set-rear-ptr! queue new-pair)
             (print-queue queue)))))

(define (delete-queue! queue)
  (if (empty-queue? queue)
    (error "The target queue if empty" queue)
    (begin 
        (set-front-ptr! queue (cdr (front-ptr queue)))
        (print-queue queue))))
(define (empty-queue? queue) (null? (front-ptr queue)))
(define (front-queue queue)
  (if (null? queue) 
        (error "The queue you passed in is null, Please create one firstly." queue)
      (car (front-ptr queue))))

; Exercise 3.21
(define (print-queue queue)
  (if (empty-queue? queue)
    (begin
        (display "The queue is empty")
        (newline))
    (begin (front-ptr queue))))

; Exercise 3.22
(define (make-que)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-que?) (null? front-ptr))
    (define (front-que) 
      (if (empty-que?)
        (error "Queue is empty")
        (car front-ptr)))
    (define (insert-que! item)
      (let ((new-pair (cons item '())))
        (cond ((empty-que?)
               (set! front-ptr  new-pair)
               (set! rear-ptr new-pair)
               front-ptr)
              (else (set-cdr! rear-ptr new-pair)
                    (set! rear-ptr new-pair)
                    front-ptr))))
    (define (delete-que!)
      (cond ((empty-que?) (error "The Queue is empty!"))
            (else (set! front-ptr (cdr front-ptr))
                  front-ptr)))
    (define (dispatch m)
      (cond ((eq? m 'empty?) empty-que?)
            ((eq? m 'front)front-que)
            ((eq? m 'insert) insert-que!)
            ((eq? m 'delete) delete-que!)
            (else "bad operation")))
    dispatch))

(define (empty-que? queue) ((queue 'empty?)))
(define (front-que queue) ((queue 'front)))
(define (insert-que! queue item) ((queue 'insert) item))
(define (delete-que! queue) ((queue 'delete)))

; Exercise 3.23
(define (make-deque)
  (let ((front-ptr '())
        (rear-ptr '()))
    (define (empty-deque?) (null? front-ptr))
    (define (front-deque)
      (if (empty-deque?) (error "Queue is empty") (car front-ptr)))
    (define (rear-deque)
      (if (empty-deque?) (error "Queue is empty") (car rear-ptr)))
    (define (print-deque)
      (define (iter head)
        (if (null? head) (display ")")
          (begin 
            (display (car head))
            (display " ")
            (iter (cddr head)))))
      (display "(")
      (iter front-ptr))

    (define (front-insert-deque! item)
      (let ((new-pair (cons item (cons '() front-ptr))))
        (if (empty-deque?)
          (begin (set! front-ptr new-pair)
                 (set! rear-ptr new-pair)
                 (print-deque))
          (begin (set-car! (cdr front-ptr) new-pair)
                 (set! front-ptr new-pair)
                 (print-deque)))))
    (define (rear-insert-deque! item)
      (if (empty-deque?)
        (let ((new-pair (cons item (cons '() '()))))
          (set! front-ptr new-pair)
          (set! rear-ptr new-pair)
          (print-deque))
        (begin (let ((new-pair (cons item (cons rear-ptr '()))))
          (set-cdr! (cdr rear-ptr) new-pair)
          (set! rear-ptr new-pair)
          (print-deque)))))
    (define (front-delete-deque!)
      (if (empty-deque?)
        (error "Queue is empty")
        (if (eq? rear-ptr front-ptr)
          (begin (set! front-ptr '()) ; the last one in queue
                 (set! rear-ptr '())
                 (print-deque))
          (begin (set! front-ptr (cddr front-ptr))
                 (set-car! (cdr front-ptr) '())
                 (print-deque)))))
    (define (rear-delete-deque!)
      (if (empty-deque?)
        (error "Queue is empty")
        (if (eq? front-ptr rear-ptr) ; the last one in queue
          (begin (set! front-ptr '())
                 (set! rear-ptr '())
                 (print-deque))
          (begin (set! rear-ptr (cadr rear-ptr))
                 (set-cdr! (cdr rear-ptr) '())
                 (print-deque)))))
    (define (dispatch m)
      (cond ((eq? m 'empty?) empty-deque?)
            ((eq? m 'front) front-deque)
            ((eq? m 'rear) rear-deque)
            ((eq? m 'front-insert) front-insert-deque!)
            ((eq? m 'rear-insert) rear-insert-deque!)
            ((eq? m 'front-delete) front-delete-deque!)
            ((eq? m 'rear-delete) rear-delete-deque!)
            (else (error "BAD METHOD -- DEQUE"))))
    dispatch))
(define (empty-deque? que) ((que 'empty?)))
(define (front-deque que) ((que 'front)))
(define (rear-deque que) ((que 'rear)))
(define (front-insert-deque! que item) ((que 'front-insert) item))
(define (rear-insert-deque! que item) ((que 'rear-insert) item))
(define (front-delete-deque! que) ((que 'front-delete)))
(define (rear-delete-deque! que) ((que 'rear-delete)))

