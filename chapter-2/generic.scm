; Chapter 2.4  genetic operations
(define container (list))
(define (get op args-type-list)
    (define (iter l)
      (if (null? l) false
        (let ((next (car l)))
          (if (and (eq? op (car next)) 
                   (equal? args-type-list (cadr next))) 
            (caddr next)
            (iter (cdr l))))))
    (iter container))
(define (put op args-type-list operator)
    (if (get op args-type-list) 
      (error "Operator with the same flag and argument types already exists")
      (set! container (cons (list op args-type-list operator) container ))))

(define (attach-type . args) 
  (cond ((= (length args) 2) (cons (car args) (cadr args)))
        ((= (length args) 1)
         (let ((value (car args)))
           (cond ((number? value) (cons 'integer value))
                 ((symbol? value) (cons 'symbol value))
                 (else (error "uncovered type" value)))))
        (else (error "Arguments for attach-type is unmatched " args))))
(define (content obj)
  (cond ((number? obj) obj)
        ((pair? obj) (cdr obj))
        (else (error "bad object to get content" obj))))
(define (type obj)
  (cond ((number? obj) 'integer)
        ((pair? obj) (car obj))
        (else (error "bad object to get type information" obj))))

(define (apply-generic op . args)
  (let ((args-type-list (map type args)))
    (let ((proc (get op args-type-list)))
      (if proc (apply proc (map content args))
        (error "No operator found" op)))))

; generic interface
(define (add x y) (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (equ? x y) (apply-generic 'equ? x y))

; public interfaces for rational number
(define (make-rational n d)
  ((get 'make-rational 'rational) n d))
(define (rat-numer r) (apply-generic 'numer r))
(define (rat-denom r) (apply-generic 'denom r))

; public interfaces for complex number
(define (make-from-real-imag real imag)
  ((get 'make-complex 'rect) real imag))
(define (make-from-magnitude-angle magni ang)
  ((get 'make-complex 'polar) magni ang))
(define (real z) (apply-generic 'real z))
(define (imag z) (apply-generic 'imag z))
(define (magni z) (apply-generic 'magni z))
(define (angl z) (apply-generic 'angl z))

(define (install-integer)
  (put 'add '(integer integer) +)
  (put 'sub '(integer integer) -)
  (put 'mul '(integer integer) *)
  (put 'div '(integer integer) /)
  (put 'equ? '(integer integer) (lambda (x y) (= x y)))
  'done)

(define (install-rational)
  (define (make-rat n d)
    (let ((g (gcd n d)))
      (cons (/ n g) (/ d g))))

  (define (numer r) (car r))
  (define (denom r) (cdr r))
  (define (add-rat x y)
    (make-rat (+ (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (- (* (numer x) (denom y))
                 (* (numer y) (denom x)))
              (* (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (* (numer x) (numer y))
              (* (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (* (numer x) (denom y))
              (* (denom x) (numer y))))
  (define (equ-rat? x y)
    (= (* (numer x) (denom y))
       (* (numer y) (denom x))))
  (define (tag r)
    (attach-type 'rational r))
  (define (domath proc . args)
    (tag (apply proc args)))

  (put 'add '(rational rational) (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational) (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational) (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational) (lambda (x y) (tag (div-rat x y))))
  (put 'make-rational 'rational (lambda (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  (put 'equ? '(rational rational) equ-rat?)
  'done)

(define (install-complex)
  (define (add-complex x y)
    (make-from-real-imag (+ (real x) (real y))
                         (+ (imag x) (imag y))))
  (define (sub-complex x y)
    (make-from-real-imag (- (real x) (real y))
                         (- (imag x) (imag y))))
  (define (mul-complex x y)
    (make-from-magnitude-angle (* (magni x) (magni y))
                               (+ (angl x) (angl y))))
  (define (div-complex x y)
    (make-from-magnitude-angle (/ (magni x) (magni y))
                               (- (angl x) (angl y))))
  (define (make-from-real-imag real imag)
    ((get 'make-complex 'complex-rect) real imag))
  (define (make-from-magnitude-angle m angl)
    ((get 'make-complex 'complex-polar) m angl))

  (define (tag z) (attach-type 'complex z))
  (put 'make-complex 'rect (lambda (real imag) 
                             (tag (make-from-real-imag real imag))))
  (put 'make-complex 'polar (lambda (m angl)
                             (tag (make-from-magnitude-angle m angl))))
  (put 'add '(complex complex) 
       (lambda (x y) (tag (add-complex x y))))
  (put 'sub '(complex complex)
       (lambda (x y) (tag (sub-complex x y))))
  (put 'mul '(complex complex)
       (lambda (x y) (tag (mul-complex x y))))
  (put 'div '(complex complex)
       (lambda (x y) (tag (div-complex x y))))
  (put 'real '(complex) real)
  (put 'imag '(complex) imag)
  (put 'magni '(complex) magni)
  (put 'angl '(complex) angl)
  (put 'equ? '(complex complex) (lambda (x y) (and (= (real x) (real y))
                                                   (= (imag x) (imag y)))))

  (define (install-complex-rect)
    (define (make-from-real-imag real imag) (cons real imag))
    (define (real z) (car z))
    (define (imag z) (cdr z))
    (define (mangni z) (sqrt (+ (square (real z)) (square (imag z)))))
    (define (angl z) (atan (imag z) (real z)))
    (put 'real '(complex-rect) real)
    (put 'imag '(complex-rect) imag)
    (put 'magni '(complex-rect) mangni)
    (put 'angl '(complex-rect) angl)
    (put 'make-complex 'complex-rect (lambda (real imag) 
                                       (attach-type 'complex-rect 
                                                    (make-from-real-imag real imag))))
    'done)
  (define (install-complex-polar)
    (define (make-from-magnitude-angle magni angl) (cons magni angl))
    (define (magni z) (car z))
    (define (angl z) (cdr z))
    (define (real z) (* (cos (angl z)) (magni z)))
    (define (imag z) (* (sin (angl z)) (magni z)))
    (put 'magni '(complex-polar) magni)
    (put 'angl '(complex-polar) angl)
    (put 'real '(complex-polar) real)
    (put 'imag '(complex-polar) imag)
    (put 'make-complex 'complex-polar (lambda (m angl)
                                        (attach-type 'complex-polar
                                                     (make-from-magnitude-angle m angl))))
    'done)
  (install-complex-rect)
  (install-complex-polar)
  'done)

(install-integer)
(install-rational)
(install-complex)
